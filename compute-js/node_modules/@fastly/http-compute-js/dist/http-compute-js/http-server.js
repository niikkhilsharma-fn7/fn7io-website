/*
 * Copyright Fastly, Inc.
 * Licensed under the MIT license. See LICENSE file for details.
 *
 * Portions of this file Copyright Joyent, Inc. and other Node contributors. See LICENSE file for details.
 */
var _a;
// This file modeled after Node.js - node/lib/_http_server.js
import { Buffer } from 'buffer';
import { ERR_HTTP_HEADERS_SENT, ERR_HTTP_INVALID_STATUS_CODE, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_INVALID_CHAR, ERR_METHOD_NOT_IMPLEMENTED, } from '../utils/errors';
import { ComputeJsOutgoingMessage } from './http-outgoing';
import { chunkExpression } from './http-common';
import { ComputeJsIncomingMessage } from './http-incoming';
import { kOutHeaders } from './internal-http';
import { EventEmitter } from "events";
/* These items copied from Node.js: node/lib/_http_common.js. */
const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
/**
 * True if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 */
function checkInvalidHeaderChar(val) {
    return headerCharRegex.exec(val) !== null;
}
export const STATUS_CODES = {
    100: 'Continue',
    101: 'Switching Protocols',
    102: 'Processing',
    103: 'Early Hints',
    200: 'OK',
    201: 'Created',
    202: 'Accepted',
    203: 'Non-Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    207: 'Multi-Status',
    208: 'Already Reported',
    226: 'IM Used',
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Found',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    307: 'Temporary Redirect',
    308: 'Permanent Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Timeout',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Payload Too Large',
    414: 'URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Range Not Satisfiable',
    417: 'Expectation Failed',
    418: 'I\'m a Teapot',
    421: 'Misdirected Request',
    422: 'Unprocessable Entity',
    423: 'Locked',
    424: 'Failed Dependency',
    425: 'Too Early',
    426: 'Upgrade Required',
    428: 'Precondition Required',
    429: 'Too Many Requests',
    431: 'Request Header Fields Too Large',
    451: 'Unavailable For Legal Reasons',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Timeout',
    505: 'HTTP Version Not Supported',
    506: 'Variant Also Negotiates',
    507: 'Insufficient Storage',
    508: 'Loop Detected',
    509: 'Bandwidth Limit Exceeded',
    510: 'Not Extended',
    511: 'Network Authentication Required' // RFC 6585 6
};
/**
 * This is an implementation of ServerResponse from Node.js intended to run in
 * Compute@Edge. The 'Writable' interface of this class is wired to an in-memory
 * buffer. This class also provides a method that creates a Response object that
 * can be handled by Compute@Edge.
 *
 * This instance can be used in normal ways, but it does not give access to the
 * underlying socket (because there isn't one. req.socket will always return null).
 *
 * Some code in this class is transplanted/adapted from node/lib/_httpserver.js
 *
 * NOTE: Node.js doesn't really separate the body from headers, the entire "stream"
 * contains the headers and the body. So we provide functions that lets us pull
 * the headers and body out individually at a later time.
 */
export class ComputeJsServerResponse extends ComputeJsOutgoingMessage {
    constructor(req) {
        super(req);
        this.statusCode = 200;
        this[_a] = null;
        this.writeHeader = this.writeHead;
        if (req.method === 'HEAD') {
            this._hasBody = false;
        }
        // this.req = req; // super() actually does this
        this.sendDate = true;
        this._sent100 = false;
        this._expect_continue = false;
        if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {
            this.useChunkedEncodingByDefault = chunkExpression.exec(String(req.headers.te)) !== null;
            this.shouldKeepAlive = false;
        }
        // Difference from Node.js -
        // In Node.js, in addition to the above, we would check if an observer is enabled for
        // http, and if it is, we would start performance measurement of server response statistics.
        // We may choose to do something like this too in the future.
        // In our implementation, we set up some event handlers to fulfill the Compute@Edge Response.
        this.computeResponse = new Promise(resolve => {
            let finished = false;
            this.on('finish', () => {
                finished = true;
            });
            const initialDataChunks = [];
            const initialDataWrittenHandler = (e) => {
                if (finished) {
                    return;
                }
                initialDataChunks[e.index] = this.dataFromDataWrittenEvent(e);
            };
            this.on('_dataWritten', initialDataWrittenHandler);
            this.on('_headersSent', (e) => {
                this.off('_dataWritten', initialDataWrittenHandler);
                // Convert the response object to Compute@Edge Response object and return it
                const { statusCode, statusMessage, headers } = e;
                resolve(this._toComputeResponse(statusCode, statusMessage, headers, initialDataChunks, finished));
            });
        });
    }
    dataFromDataWrittenEvent(e) {
        const { index, entry } = e;
        let { data, encoding } = entry;
        if (index === 0) {
            if (typeof data !== 'string') {
                console.error('First chunk should be string, not sure what happened.');
                throw new ERR_INVALID_ARG_TYPE('packet.data', ['string', 'Buffer', 'Uint8Array'], data);
            }
            // The first X bytes are header material, so we remove it.
            data = data.slice(this.writtenHeaderBytes);
        }
        if (typeof data === 'string') {
            if (encoding === undefined || encoding === 'utf8' || encoding === 'utf-8') {
                data = ComputeJsServerResponse.encoder.encode(data);
            }
            else {
                data = Buffer.from(data, encoding);
            }
        }
        return data;
    }
    _finish() {
        // Difference from Node.js -
        // In Node.js, if server response statistics performance is being measured, we would stop it.
        super._finish();
    }
    assignSocket(socket) {
        // Difference from Node.js -
        // Socket is not supported
        throw new ERR_METHOD_NOT_IMPLEMENTED('assignSocket');
    }
    detachSocket(socket) {
        // Difference from Node.js -
        // Socket is not supported
        throw new ERR_METHOD_NOT_IMPLEMENTED('detachSocket');
    }
    writeContinue(callback) {
        this._writeRaw('HTTP/1.1 100 Continue\r\n\r\n', 'ascii', callback);
        this._sent100 = true;
    }
    writeProcessing(callback) {
        this._writeRaw('HTTP/1.1 102 Processing\r\n\r\n', 'ascii', callback);
    }
    _implicitHeader() {
        this.writeHead(this.statusCode);
    }
    writeHead(statusCode, reason, obj) {
        const originalStatusCode = statusCode;
        statusCode |= 0;
        if (statusCode < 100 || statusCode > 999) {
            throw new ERR_HTTP_INVALID_STATUS_CODE(originalStatusCode);
        }
        if (typeof reason === 'string') {
            // This means this was called as:
            // writeHead(statusCode, reasonPhrase[, headers])
            this.statusMessage = reason;
        }
        else {
            // This means this was called as:
            // writeHead(statusCode[, headers])
            if (!this.statusMessage)
                this.statusMessage = STATUS_CODES[statusCode] || 'unknown';
            obj = reason;
        }
        this.statusCode = statusCode;
        let headers;
        if (this[kOutHeaders]) {
            // Slow-case: when progressive API and header fields are passed.
            let k;
            if (Array.isArray(obj)) {
                if (obj.length % 2 !== 0) {
                    throw new ERR_INVALID_ARG_VALUE('headers', obj);
                }
                for (let n = 0; n < obj.length; n += 2) {
                    k = obj[n];
                    if (k) {
                        this.setHeader(k, obj[n + 1]);
                    }
                }
            }
            else if (obj) {
                const keys = Object.keys(obj);
                // Retain for(;;) loop for performance reasons
                // Refs: https://github.com/nodejs/node/pull/30958
                for (let i = 0; i < keys.length; i++) {
                    k = keys[i];
                    if (k) {
                        this.setHeader(k, obj[k]);
                    }
                }
            }
            if (k === undefined && this._header) {
                throw new ERR_HTTP_HEADERS_SENT('render');
            }
            // Only progressive api is used
            headers = this[kOutHeaders];
        }
        else {
            // Only writeHead() called
            headers = obj;
        }
        if (checkInvalidHeaderChar(this.statusMessage)) {
            throw new ERR_INVALID_CHAR('statusMessage');
        }
        const statusLine = `HTTP/1.1 ${statusCode} ${this.statusMessage}\r\n`;
        if (statusCode === 204 || statusCode === 304 ||
            (statusCode >= 100 && statusCode <= 199)) {
            // RFC 2616, 10.2.5:
            // The 204 response MUST NOT include a message-body, and thus is always
            // terminated by the first empty line after the header fields.
            // RFC 2616, 10.3.5:
            // The 304 response MUST NOT contain a message-body, and thus is always
            // terminated by the first empty line after the header fields.
            // RFC 2616, 10.1 Informational 1xx:
            // This class of status code indicates a provisional response,
            // consisting only of the Status-Line and optional headers, and is
            // terminated by an empty line.
            this._hasBody = false;
        }
        // Don't keep alive connections where the client expects 100 Continue
        // but we sent a final status; they may put extra bytes on the wire.
        if (this._expect_continue && !this._sent100) {
            this.shouldKeepAlive = false;
        }
        this._storeHeader(statusLine, headers !== null && headers !== void 0 ? headers : null);
        return this;
    }
    _toComputeResponse(status, statusText, sentHeaders, initialDataChunks, finished) {
        const headers = new Headers();
        for (const [key, value] of Object.entries(sentHeaders)) {
            headers.append(key, value);
        }
        const _this = this;
        const body = this._hasBody ? new ReadableStream({
            start(controller) {
                for (const dataChunk of initialDataChunks) {
                    controller.enqueue(dataChunk);
                }
                if (finished) {
                    controller.close();
                }
                else {
                    _this.on('finish', () => {
                        finished = true;
                        controller.close();
                    });
                    _this.on('_dataWritten', (e) => {
                        if (finished) {
                            return;
                        }
                        const data = _this.dataFromDataWrittenEvent(e);
                        controller.enqueue(data);
                    });
                }
            },
        }) : null;
        return new Response(body, {
            status,
            statusText,
            headers,
        });
    }
}
_a = kOutHeaders;
ComputeJsServerResponse.encoder = new TextEncoder();
export function toReqRes(req, options) {
    const { createIncomingMessage = () => new ComputeJsIncomingMessage(), createServerResponse = (incoming) => new ComputeJsServerResponse(incoming), ctx, } = options !== null && options !== void 0 ? options : {};
    const incoming = createIncomingMessage(ctx);
    const serverResponse = createServerResponse(incoming, ctx);
    const reqUrl = new URL(req.url);
    // In C@E I don't think you can actually detect HTTP version, so we'll use 1.1
    // Who uses this anyway?
    const versionMajor = 1;
    const versionMinor = 1;
    incoming.httpVersionMajor = versionMajor;
    incoming.httpVersionMinor = versionMinor;
    incoming.httpVersion = `${versionMajor}.${versionMinor}`;
    incoming.url = reqUrl.pathname + reqUrl.search;
    incoming.upgrade = false; // TODO: support this, if there is some way to do it
    const headers = [];
    for (const [headerName, headerValue] of req.headers) {
        headers.push(headerName);
        headers.push(headerValue);
    }
    incoming._addHeaderLines(headers, headers.length);
    incoming.method = req.method;
    incoming._stream = req.body;
    return {
        req: incoming,
        res: serverResponse,
    };
}
export function toComputeResponse(res) {
    if (!(res instanceof ComputeJsServerResponse)) {
        throw new Error('toComputeResponse must be called on ServerResponse generated by generateRequestResponse');
    }
    return res.computeResponse;
}
/**
 * This class simplifies the creation of a request event listener that provides
 * access to IncomingMessage and ServerResponse in Compute@Edge. Its interface
 * is inspired by http.Server from Node.js.
 */
export class HttpServer extends EventEmitter {
    constructor(_options) {
        // options is currently unused.
        super();
        this._listening = false;
    }
    listen(port, onListen) {
        if (this._listening) {
            throw new Error(`Cannot call 'listen()' more than once on a single HttpServer instance.`);
        }
        if (typeof port === 'function') {
            onListen = port;
            port = undefined;
        }
        if (port != null) {
            console.warn('Cannot set port programmatically. The port used is determined by the Compute@Edge environment.');
        }
        if (onListen != null) {
            console.log(`Attaching 'listening' listener, but note that this event runs outside the context of handling a request.`);
            this.on('listening', onListen);
        }
        const handleRequest = async (event) => {
            // Create Node.js-compatible request and response from event.request
            const { req, res } = toReqRes(event.request);
            this.emit('request', req, res);
            // Convert the object to Compute@Edge-compatible response
            return await toComputeResponse(res);
        };
        addEventListener("fetch", (event) => event.respondWith(handleRequest(event)));
    }
}
/**
 * Simplifies the creation of the HttpServer instance. Its interface
 * is inspired by http.createServer from Node.js.
 */
export function createServer(options, onRequest) {
    if (typeof options === 'function') {
        onRequest = options;
        options = undefined;
    }
    const server = new HttpServer(options);
    if (onRequest != null) {
        server.on('request', onRequest);
    }
    return server;
}
