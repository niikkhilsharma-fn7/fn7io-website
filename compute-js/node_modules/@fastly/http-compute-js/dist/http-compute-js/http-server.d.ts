/// <reference types="@fastly/js-compute" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { Buffer } from 'buffer';
import type { IncomingMessage, OutgoingHttpHeader, OutgoingHttpHeaders, ServerResponse } from 'http';
import { ComputeJsOutgoingMessage, DataWrittenEvent } from './http-outgoing';
import { ComputeJsIncomingMessage } from './http-incoming';
import { kOutHeaders } from './internal-http';
import { EventEmitter } from "events";
export declare const STATUS_CODES: Record<number, string>;
/**
 * This is an implementation of ServerResponse from Node.js intended to run in
 * Compute@Edge. The 'Writable' interface of this class is wired to an in-memory
 * buffer. This class also provides a method that creates a Response object that
 * can be handled by Compute@Edge.
 *
 * This instance can be used in normal ways, but it does not give access to the
 * underlying socket (because there isn't one. req.socket will always return null).
 *
 * Some code in this class is transplanted/adapted from node/lib/_httpserver.js
 *
 * NOTE: Node.js doesn't really separate the body from headers, the entire "stream"
 * contains the headers and the body. So we provide functions that lets us pull
 * the headers and body out individually at a later time.
 */
export declare class ComputeJsServerResponse extends ComputeJsOutgoingMessage implements ServerResponse {
    static encoder: TextEncoder;
    statusCode: number;
    statusMessage: string;
    _sent100: boolean;
    _expect_continue: boolean;
    [kOutHeaders]: Record<string, any> | null;
    constructor(req: IncomingMessage);
    dataFromDataWrittenEvent(e: DataWrittenEvent): Buffer | Uint8Array;
    _finish(): void;
    assignSocket(socket: any): void;
    detachSocket(socket: any): void;
    writeContinue(callback?: () => void): void;
    writeProcessing(callback?: () => void): void;
    _implicitHeader(): void;
    writeHead(statusCode: number, reason?: string | OutgoingHttpHeaders | OutgoingHttpHeader[], obj?: OutgoingHttpHeaders | OutgoingHttpHeader[]): this;
    writeHeader: (statusCode: number, reason?: string | OutgoingHttpHeaders | OutgoingHttpHeader[], obj?: OutgoingHttpHeaders | OutgoingHttpHeader[]) => this;
    computeResponse: Promise<Response>;
    _toComputeResponse(status: number, statusText: string, sentHeaders: Record<string, string>, initialDataChunks: (Buffer | Uint8Array)[], finished: boolean): Response;
}
export declare type ReqRes = {
    req: IncomingMessage;
    res: ServerResponse;
};
export declare type ToReqResOptions = {
    createIncomingMessage?: (ctx?: any) => ComputeJsIncomingMessage;
    createServerResponse?: (incomingMessage: ComputeJsIncomingMessage, ctx?: any) => ComputeJsServerResponse;
    ctx?: any;
};
export declare function toReqRes(req: Request, options?: ToReqResOptions): ReqRes;
export declare function toComputeResponse(res: ServerResponse): Promise<Response>;
export declare type HttpServerOptions = {};
export declare type RequestListener = (req: IncomingMessage, res: ServerResponse) => void;
export declare type ListenListener = () => void;
/**
 * This class simplifies the creation of a request event listener that provides
 * access to IncomingMessage and ServerResponse in Compute@Edge. Its interface
 * is inspired by http.Server from Node.js.
 */
export declare class HttpServer extends EventEmitter {
    constructor(_options?: HttpServerOptions);
    _listening: boolean;
    listen(port?: number | ListenListener, onListen?: ListenListener): void;
}
/**
 * Simplifies the creation of the HttpServer instance. Its interface
 * is inspired by http.createServer from Node.js.
 */
export declare function createServer(options?: HttpServerOptions | RequestListener, onRequest?: RequestListener): HttpServer;
//# sourceMappingURL=http-server.d.ts.map